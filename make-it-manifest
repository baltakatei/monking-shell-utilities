#!/bin/bash

FILE_DEFAULT="manifest.txt"

treeFurtherOptions=()

showHelp() {
  {
    echo "Save the output of tree, tab-indented, to a $FILE_DEFAULT file.."
    echo "USAGE: make-it-manifest [OPTIONS]"
    echo "OPTIONS:"
    echo " -a      Include hidden files (i.e. file/directory names beginning with '.'."
    echo " -e CMD  Run a command with '{}' replaced with filename, output of which is put on the line after the file (see tree-tab -e)."
    echo " -E      Open the manifest file EDITOR (set environment variable to configure). This option is ignored if you specify -f -, for output to stdout."
    echo " -d DIR  Specify the directory of which to make a manifest. This defaults to PWD."
    echo " -D      Show debug messages."
    echo " -g      Note the commit hash of any git repositories."
    echo " -G      Recurse into Git repositories. By default the contents of git repositories is ignored."
    echo " -N      Recurse into node_module directories, ignored by default."
    echo " -l      Follow symlinks."
    echo " -m      Include the MD5 sum for each file in the output manifest."
    echo " -o FILE Specify the manifest file location. By default, it's DIR/$FILE_DEFAULT. If '-' is given, the manifest is output to stdout, and not saved to disk."
    echo " -h      Show this help."
    echo " -t      Append a timestamp to the manifest filename. It is assumed that the file has extention .txt, and this option will fail if you specify a different extension. If using with -o, specify -o before -t. -t is ignored if you specify -o - (i.e. output to stdout)."
    echo ""
    echo "The manifest will be opened in an editor (value of EDITOR environment variable."
    echo ""
    echo "Dependencies: date, tree-tab, -m[ md5sum, awk ], -g[ git ], -L[ readlink ]"
  } >&2
}

generateManifest() {
  local fullPath="$(cd "$1"; pwd)"
  [[ -n $TENT_HOSTNAME ]] && HOSTNAME="$TENT_HOSTNAME"
  echo "$HOSTNAME:$fullPath"
  [[ -n $2 ]] && echo "manifest captured: $2" # timestamp, or other information
  local includeMD5=$3
  (
    cd "$fullPath"
    {
      treeCommand=(tree-tab)
      [[ $includeDotFiles = true ]] && treeCommand+=(-a)
      [[ $debug = true ]] && treeCommand+=(-D)
      [[ $includeMD5 = true ]] && treeCommand+=(-e "[[ -f \"{}\" ]] && echo -n \"\$(md5sum \"{}\" | awk '{ print \$1 }')\"")
      [[ $followSymlinks = true ]] && treeCommand+=(-l -e "[[ -L \"{}\" ]] && { echo -n ' -> '; readlink \"{}\"; }")
      [[ $includeHiddenFiles = true ]] && treeCommand+=(-a)
      [[ $recurseIntoGitRepositories != true ]] && treeCommand+=(--ignore-path '\.git/.+') # ignore files within a git repository, list the repository root directory
      [[ $recurseIntoNodeModules != true ]] && treeCommand+=(--ignore-path 'node_modules/') # ignore files within a git repository, list the repository root directory
      [[ $noteGitRevision = true ]] && treeCommand+=(-e 'if [[ "{}" =~ \.git$ ]]; then echo -n "commit:$(cd "{}" && git rev-parse HEAD)"; elif [[ "{}" =~ \.bundle$ ]]; then echo -n "commit:$(git bundle list-heads "{}" | grep " HEAD\$" | awk "{ print \$1 }")"; fi') # {:01jjmnk} recurring error:<d:n/>```<d:n/>fatal: not a git repository (or any of the parent directories): .git<d:n/>```<d:n/>Oh, it [ ] might be a text `.git` file in a submodule, referring to its legit `.git` dir in `PARENT_GIT_WORKING_COPY/.git/modules/some-submodule/.git`<d:n/><d:n/>[ ] at least print out a path, rather thna the same exact error with no context.
      [[ ${#treeFurtherOptions[@]} -gt 0 ]] && treeCommand+=("${treeFurtherOptions[@]}")
      "${treeCommand[@]}"
    } |
      grep -v '^\.$' # leave off top dir path, our own header serves that need
  )
}

editFile() {
  "$EDITOR" -s <(echo -e ":set fdm=indent\n") "$1"
}

editAfter=false
computeMD5PerFile=false
debug=false
dir="$PWD"
file="$FILE_DEFAULT"
timestamp="$(TZ=UTC date '+%Y%m%dT%H%M%SZ')"
includeDotFiles=false
noteGitRevision=false
recurseIntoGitRepositories=false
recurseIntoNodeModules=false
followSymlinks=false
while getopts ad:De:EgGhlmo:t flag; do
  case $flag in
    a) includeDotFiles=true;;
    d) dir="$OPTARG";;
    D) debug=true;;
    e) treeFurtherOptions+=(-e "$OPTARG");;
    E) editAfter=true;;
    g) noteGitRevision=true;;
    G) recurseIntoGitRepositories=true;;
    N) recurseIntoNodeModules=true;;
    h) showHelp; exit 0;;
    l) followSymlinks=true;;
    m) computeMD5PerFile=true;;
    o) file="$OPTARG";;
    t) file="${file/.txt/.$timestamp.txt}";;
  esac
done

{
  genManCommand=(generateManifest "$dir" "$timestamp" $computeMD5PerFile)
  if [[ $file != '-' ]]; then # write to disk, and optionally edit
    echo "Generating manifest in file $file" >&2
    "${genManCommand[@]}" > "$file" &&
      [[ $editAfter = true ]] &&
      editFile "$file"
  elif $editAfter; then # stdout + edit
    echo "Generating manifest in file $file" >&2
    echo "Will open in editor afterwards." >&2
    "${genManCommand[@]}" | editFile "$file"
  else # stdout
    "${genManCommand[@]}"
  fi
}

# TODO
# {:01ikwAR} [?] option to record files' modified time in the manifest ({01jOnUC} [?] +size)
# {:01jEiby} TODO: [?] follow submodule text `.git` file references to get their commit hash.\n\n```\n$ file some/submodule/.git\nsome/submodule/.git: ASCII text\n\n$ cat some/submodule/.git\ngitdir: ../.git/modules/bin\n\n$ git --git-dir=some/submodule/../.git/modules/submodule rev-parse HEAD\naecd7b12cfe3b8ada55f16534a1325f12deb258e\n```
